/*
 * WIRELESS ETTL FLASH CONVERSION
 * Copyright (C) 2022 Adam Williams <broadcast at earthling dot net>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 */

#ifndef WIRELESS_H
#define WIRELESS_H


// print the clock waveform before a timeout
// #define DEBUG_TIMEOUT
// print raw bytes instead of packets
//#define DEBUG_RAW

// if neither of these is enabled, it just captures the dialog
// transmitter mode
// Enable the simulated flash
//#define SIM_FLASH

// receiver mode
// Enable the simulated camera
#define SIM_CAM







// GPIO pins for output mode
#define X_PIN 2
#define ID_PIN 3
// common pin for D1, D2
#define D_PIN 5
#define CLK_PIN 4
#define LED_PIN 14

#define D_GPIO GPIOA
#define CLK_GPIO GPIOA
#define X_GPIO GPIOC
#define ID_GPIO GPIOC
#define LED_GPIO GPIOC

#define RADIO_UART_GPIO GPIOA
#define RADIO_RX_PIN 10
#define RADIO_TX_PIN 9

#include <stdint.h>

// parsed data
// captured byte from flash
extern uint8_t d1_value;
// captured byte to flash
extern uint8_t d2_value;
// generated byte for D1
extern uint8_t d1_sim;
// generated byte for D2
extern uint8_t d2_sim;
extern int have_d2_sim;
extern int x_value;
extern int id_value;
extern int bit_counter;
// raise D1 after every byte for flow control
extern int d1_sim_timeout;
#define D1_SIM_TIMEOUT 30
// analog readouts
extern int clk_raw;
extern int d1_raw;
extern int d2_raw;
extern int id_raw;
// ADC is reading ID instead of D1
extern int reading_id;
extern int byte_counter;

//#define ADC_SAMPLE_TIME ADC_SampleTime_3Cycles
#define ADC_SAMPLE_TIME ADC_SampleTime_15Cycles
//#define ADC_SAMPLE_TIME ADC_SampleTime_28Cycles
//#define ADC_SAMPLE_TIME ADC_SampleTime_56Cycles

extern uint8_t packet_id;

// radio bits
#define RADIO_PACKETSIZE 10
// unencoded packet
extern uint8_t radio_packet[RADIO_PACKETSIZE * 2];

// buffer for receive/transmit
// must buffer more than 1 packet with resends
#define RADIO_BUFSIZE 128
extern uint8_t radio_buffer[];
extern volatile int radio_size;
extern volatile int radio_write_ptr;
extern volatile int radio_read_ptr;
extern uint8_t radio_data;
#define RADIO_IDLE 0
#define RADIO_WARMUP 1
#define RADIO_TRANSMIT 2
#define RADIO_RECEIVE 3
extern int radio_state;

extern const uint8_t salt[RADIO_PACKETSIZE * 2];


// send codes for flash triggers
#define TRIGGER_IDLE 0
#define TRIGGER_PREFLASH 1
#define TRIGGER_FLASH 2
extern int trigger_state;
#define TRIGGER_CODE_NONE 0
#define TRIGGER_CODE_CLK 0xaa // CLK 0V
#define TRIGGER_CODE_X 0x55 // CLK & X 0V
extern uint8_t trigger_code;
#define TRIGGER_DEBOUNCE 2


// faster transition than setting the DAC
// disable the DAC to get high voltage
#define SET_D DAC->CR &= ~(DAC_CR_EN1 << DAC_Channel_2);
// enable the DAC to get 2V digital 0
#define CLEAR_D DAC->CR |= (DAC_CR_EN1 << DAC_Channel_2);
#define SET_CLK DAC->CR &= ~(DAC_CR_EN1 << DAC_Channel_1);
#define CLEAR_CLK DAC->CR |= (DAC_CR_EN1 << DAC_Channel_1);

#define ENABLE_BIT_TIMER TIM10->CR1 |= TIM_CR1_CEN;
#define DISABLE_BIT_TIMER TIM10->CR1 &= (uint16_t)~TIM_CR1_CEN;
#define RESET_BIT_TIMER \
    TIM10->CNT = 0; \
    TIM10->SR = ~TIM_FLAG_Update;
#define SET_BYTE_TIMER(x) \
    TIM2->CNT = -(x); \
    TIM2->SR = (uint16_t)~TIM_FLAG_Update;
#define BYTE_TIMER_EXPIRED (TIM2->SR & TIM_FLAG_Update)


#define ENABLE_RADIO_TIMER TIM5->CR1 |= TIM_CR1_CEN;
#define DISABLE_RADIO_TIMER TIM5->CR1 &= (uint16_t)~TIM_CR1_CEN;
#define SET_RADIO_TIMER(x) \
    TIM5->CNT = -(x); \
    TIM5->SR = (uint16_t)~TIM_FLAG_Update;

#define START_ADC2 ADC2->CR2 |= (uint32_t)ADC_CR2_SWSTART;


// observed voltage ranges
// CLK RANGE: 163 255 
// D1 RANGE: 155 250 
// D2 RANGE: 168 253 
// ID RANGE: 0 108

#define CLK_HIGH ((163 + 255) / 2)
#define CLK_LOW 80
#define ID_HIGH 54
#define D1_HIGH ((155 + 250) / 2)
#define D2_HIGH ((168 + 253) / 2)
#define SIM_D1_LOW 168
#define SIM_D2_LOW 168

// micro seconds
// maximum time to wait for the next bit
#define BIT_TIMEOUT 40
// when to print the byte counter for debugging
#define BYTE_TIMEOUT 20000
// when to reset the packet parser because of a glitch
#define PACKET_TIMEOUT 80000
// Wait this long for trigger codes
#define TRIGGER_TIMEOUT 1000000
// wait this many us before transmitting
#define RADIO_WARMUP_TIME 5000
// turn off radio after this many us of inactivity
#define RADIO_TIMEOUT 1000000

#define PACKET_MAX 128
// the last captured packet
// captured or simulated data to the flash
extern uint8_t toflash_data[PACKET_MAX];
// captured or simulated data from the flash
extern uint8_t fromflash_data[PACKET_MAX];
// bytes captured
extern int capture_size;
// offset in simulated packet
extern int sim_offset;
// size of simulated packet
extern int sim_size;

// offsets of variable bytes in each packet type, null terminated
// Must be smaller than RADIO_PACKETSIZE - 2
extern const uint8_t poweron_vars[];
extern const uint8_t metering1_vars[];
extern const uint8_t preflash1_vars[];
extern const uint8_t maneflash1_vars[];
extern const uint8_t maneflash2_vars[];

// type of packet captured
#define TYPE_NONE 0
#define TYPE_POWERON 1
#define TYPE_METERING1 2
#define TYPE_METERING2 3
#define TYPE_PREFLASH1 4
#define TYPE_PREFLASH2 5
#define TYPE_MANE_FLASH1 6
#define TYPE_MANE_FLASH2 7
#define TYPE_FAST_FLASH 8
#define TYPE_MANUAL_FLASH 9
extern int packet_type;

// number of times to repeat each packet
extern const uint8_t repeats[];
// tables of variables for each packet
extern const uint8_t *var_offsets[];
extern const int ref_packet_size[];
extern const uint8_t* ref_packets[];

void init_radio();
void radio_off();
void transmitter_on();

void usleep(int us);
void camera_loop();
void flash_loop();




#endif


